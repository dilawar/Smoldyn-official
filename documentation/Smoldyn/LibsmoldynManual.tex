% Libsmoldyn manual

\documentclass {book}


% packages
\usepackage{longtable}
\usepackage{listings}
\usepackage{url}

% settings for listings package
\lstset{
language=C, 
basicstyle=\small\ttfamily, 
keywordstyle=\bfseries, 
tabsize=2, 
breaklines=true, 
breakatwhitespace=false
}

% settings for longtable package
\setlength\LTleft\parindent
\setlength\LTright\fill


\newcommand {\ttt} {\texttt}

% Paper size and margins
\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}

\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0.25in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}


\begin{document}

% line termination tolerance, this still isn't working well enough to avoid overfull hboxes
\tolerance=10000
\pretolerance=10000



\title{\textbf{Libsmoldyn User's Manual} \\ \large for Smoldyn version 2.62}
\date{\copyright October, 2020}
\author{Steve Andrews}
\maketitle

\tableofcontents


% Chapter: About Libsmoldyn
\chapter{About Libsmoldyn}
Libsmoldyn is a C, C++, and Python interface to the Smoldyn simulator. Libsmoldyn is complementary to the stand-alone Smoldyn program in that it is a little more difficult to use, but it provides much more flexibility. In addition, Libsmoldyn provides: (\emph{i}) an application programming interface (API) that will be relatively stable, even as Smoldyn is updated and improved, (\emph{ii}) function names that are relatively sensible and that shouldn't collide with other function names in other software, and (\emph{iii}) reasonably thorough error checking in every function which helps ensure that the user is using the function in a sensible way and in a way that won't crash Smoldyn.

Libsmoldyn was originally written as a C API, but one that should work with C++ as well. Then, in 2019 and 2020, Dilawar Singh added Python bindings to it, which are still quite new but generally work well.

Libsmoldyn only barely supports graphics at present due to constraints imposed by the glut code library. This will be improved in a future version (by changing to the freeglut library, which doesn't insist on controlling the main event loop, as the glut library does).


% Chapter: Linking with C/C++
\chapter{Linking with C/C++}

% Compiling
\section{Compiling}

\subsection*{Header files}
To enable a C or C++ program to call Libsmoldyn, it has to include the Libsmoldyn header file. Libsmoldyn comes with one header file, libsmoldyn.h, which has function declarations for all of the Libsmoldyn functions. For most Libsmoldyn applications, this is the only header file that you will need to include. For Mac and Linux, it is typically installed to /usr/local/include. This is one of the standard system paths, so include it with

\begin{quote}
\lstinline{#include <libsmoldyn.h>}
\end{quote}

If the libsmoldyn.h header file is in some other directory or if your system isn't seeing its path as a system path, then include the file using double quotes rather than angle brackets and/or include more information about the path. For example, \lstinline{#include "/user/local/include/libsmoldyn.h"}.

Libsmoldyn.h calls a second header file, smoldyn.h, which is also typically installed to /usr/local/include/. If you plan to access the Smoldyn data structure directly, then you will also need to include it with \lstinline{#include <smoldyn.h>}. In general, it is safe to read from this data structure but it can be dangerous to write to it unless you really know what you are doing. Also, working with this data structure directly bypasses one of the benefits of using Libsmoldyn, which is that the interface should be relatively immune to future Smoldyn developments, because different aspects of the internal data structure get changed once in a while.

The smoldyn.h header calls yet another header file, smoldynconfigure.h, which is also installed by default in /usr/local/include/. That file is automatically generated by the build system. It describes what Smoldyn components are included in the build, what system the build was compiled for, etc. This might be helpful to include for some applications.

\subsection*{Compiling example}
In the \ttt{examples/S97\_libsmoldyn/testcode/} directory, you'll find the testcode.c program. To compile this source code to object code, enter:

\begin{quote}
\lstinline{gcc -Wall -O0 -g -c testcode.c}
\end{quote}

The compile flags \ttt{-O0 -g} aren't necessary but can be useful for debugging purposes. If compiling doesn't work at this stage, it's probably because you're missing the header files. Make sure that you have libsmoldyn.h, smoldyn.h, and smoldyn\_config.h in the \ttt{/usr/local/include} directory.

% Linking
\section{Linking}

Linking the different object files together to create an executable that actually runs is often one of the greatest frustrations of using software libraries. It should be easy but usually isn't.

The Libsmoldyn library can be linked statically, meaning that the Libsmoldyn code will be copied into the final result, or it can be linked dynamically, so that the final result will simply reference the Libsmoldyn code that is stored separately. Dynamic linking is somewhat more elegant in that it doesn't create unnecessary copies of the compiled code. It can also be easier. On the other hand, it's less convenient if you plan to distribute your software, because then you need to make sure that you distribute the Libsmoldyn header file and library code along with your own software. Also, I can only get the gdb debugger to help find errors within Libsmoldyn if the library is statically linked.

The Libsmoldyn static library is called libsmoldyn\_static.a and the Libsmoldyn dynamic library is called libsmoldyn\_shared.so (on Linux; the .so suffix is replaced by .dylib on a Mac and by .dll on Windows). By default, these libraries are installed to /usr/local/lib/.

\subsection*{Linking examples}

Following are several example for static and dynamic linking. They are shown for C; if you use C++, then link with g++ instead of gcc. The linking options for Smoldyn compiled with OpenGL are shown for Macintosh; these lines are simpler for other systems.

I have had a hard time getting static linking working on a Mac, although apparently it works fine on Ubuntu. The problem is that it doesn't find the standard C++ library. The solution is to build the Smoldyn library without NSV, so that the standard C++ library isn't needed. I also commented out a few ``throw'' statements from smolsim.c and libsmoldyn.c for this purpose.

Static link, no OpenGL:
\begin{quote}
\lstinline{gcc testcode.o /usr/local/lib/libsmoldyn_static.a -o testcode}
\end{quote}

Static link, with OpenGL:
\begin{quote}
\lstinline{gcc testcode.o /usr/local/lib/libsmoldyn_static.a -I/System/Library/Frameworks/OpenGL.framework/Headers -I/System/Library/Frameworks/GLUT.framework/Headers -framework GLUT -framework OpenGL -framework Cocoa -L/System/Library/Frameworks/OpenGL.framework/Libraries -o testcode -ltiff}
\end{quote}

Dynamic link, no OpenGL:
\begin{quote}
\lstinline{gcc testcode.o -o testcode -lsmoldyn_shared}
\end{quote}

Dynamic link, with OpenGL:
\begin{quote}
\lstinline{gcc test1.o -L/usr/local/lib -I/System/Library/Frameworks/OpenGL.framework/Headers -I/System/Library/Frameworks/GLUT.framework/Headers -framework GLUT -framework OpenGL -framework Cocoa -L/System/Library/Frameworks/OpenGL.framework/Libraries -o test1 -lsmoldyn_shared -ltiff}
\end{quote}


% Chapter: Use with Python
\chapter{Use with Python}

\section{Installing}

Hopefully, you should be able to install using
\begin{verbatim}
python3 -m pip install smoldyn --user --pre
\end{verbatim}
This should install the smoldyn nightly package, from: \url{https://pypi.org/project/smoldyn/}

Alternatively, the Mac distribution comes with a Python wheel, called something like smoldyn-2.62-py3-none-any.whl. You should be able to write ``pip install smoldyn...whl'' and that will install it for you as well.

For Windows, ``pip install smoldyn'' seems to work initially, but it doesn't install the necessary compiled code, so it doesn't actually run, yet.

\section{Command line flags}

The Python interface offers the following command line flags:

\begin{longtable}[c]{ll}
Flags & Function\\
\hline
\ttt{input} & Load input file\\
\ttt{--overwrite}, \ttt{-w} & Overwrite any existing data file\\
\ttt{--quit-at-end}, \ttt{-q} & Quit when the simulation is complete\\
\ttt{--args}, \ttt{-A} & Smoldyn command line arguments
\end{longtable}

\section{Files}

After building Smoldyn (assuming you were in \ttt{/path/to/Smoldyn-official/build} directory when you ran \ttt{make} command), the python module ends up in the \ttt{/path/to/Smoldyn-official/build/py} directory. The module can be imported into Python from this directory. Add this directory to your
\ttt{PYTHONPATH} temporarily with \ttt{export PTYHONPATH=/path/to/Smoldyn-official/build/py:\$PYTHONPATH}. With this, the module can be accessed from any directory.

Note that it's possible to see where the library is imported from by checking
\verb|smoldyn.__file__| while in Python. For example,

\begin{verbatim}
>>> import smoldyn
>>> print(smoldyn.__file__)
/home/dilawars/Work/FORKES/Smoldyn-official/build/py/smoldyn/__init__.py
\end{verbatim}


\section{Python-specific functionality}

Python offers a callback function that enables Smoldyn setup functions to be called repeatedly and automatically. Following is the text from Dilawar's description.

Suppose I have the following function which generates a noisy value using the current time \ttt{t} and a list of arguments \ttt{args}.

\begin{verbatim}
def computeVm(t, args):
    x, y = args 
    return math.sin(t) + x * y + random.random()
\end{verbatim}

And I have a molecular species \ttt{ca}.

\begin{verbatim}
import smoldyn
ca = smoldyn.Species('ca', difc=1, color='blue', display_size=1)
\end{verbatim}
Then the following connect the output of function computeVm to ca.difc parameter. This is called every 10th step.

\begin{verbatim}
smoldyn.connect(computeVm, "ca.difc", step=10, args=[1,2.1])
\end{verbatim}

In smoldyn.connect function, both source and target must be global variables. In the example below, I made a a global variable before I used it in connect. Else there will be a runtime error.

\begin{verbatim}
import smoldyn as S
import random

a = None

def new_dif(t, args):
    global a
    x, y = args
    print(a.difc)
    return t + random.random()

def test_connect():
    global a
    S.setBounds(low=(0, 0), high=(10, 10))
    a = S.Species("a", color="red", difc=1)
    S.connect(new_dif, "a.difc", step=10, args=[0, 1])
    s = S.Simulation(100, 1)
    s.run()
    print("All done")

test_connect()
\end{verbatim}

Also accepts a function.

\begin{verbatim}
def new_dif(t, args):
    global a, avals
    x, y = args
    # note that b.difc is not still updated.
    avals.append((t, a.difc["soln"]))
    return x * math.sin(t) + y

def update_difc(val):
    global a
    a.difc = val

def test_connect():
    global a, avals
    S.setBounds(low=(0, 0), high=(10, 10))
    a = S.Species("a", color="black", difc=0.1)
    S.connect(new_dif, update_difc, step=10, args=[1, 1])
    s = S.Simulation(100, 1)
    s.run()
    for a, b in zip(avals[1:], expected_a[1:]):
        print(a, b)
        assert math.isclose(a[1], b[1], rel_tol=1e-6, abs_tol=1e-6), (a[1], b[1])

test_connect()
\end{verbatim}

Dilawar created some nice examples of this in use with a pre-synaptic bouton with N synaptic vesicles. These vesicles fuse with the bottom of the bouton (red surface). Upon fusion, one vesicle releases 1000 neurotransmitters which decay with time-constant $\tau$.

The rate of release is controlled by a function. This is set by smoldyn.connect. The function generates s spike 0 or 1, if the value is 1 the rate is set to 1000 else it is 0.

% Chapter: Error trapping
\chapter{Error trapping for C/C++ API}

Every function in Libsmoldyn checks that its input values are acceptable and also that no errors arise in the function execution. These errors are returned to the host library in a number of ways. Most Libsmoldyn functions (e.g. \ttt{smolRunSim}) return any error codes directly, which makes it easy to see if an error arose. However, a few functions (e.g. \ttt{smolNewSim}) return other types of values and so return some other indication of success or failure (e.g. \ttt{NULL}). In addition, some functions can raise warnings, which indicate that behavior is unusual but not incorrect.

For all of these errors and warnings, get the details of the problem using the function \ttt{smolGetError}, which will return the error code, the name of the function where the error arose, and a descriptive error string. This will also clear the error, if desired. If errors are not cleared, they are left until they are overwritten by subsequent errors. Warnings are also left until they are cleared or overwritten.

When writing code, it can be helpful to put Libsmoldyn into its debugging mode using the \ttt{smolSetDebugMode} function. Doing this causes any errors that arise to be displayed to stderr.

The possible error codes are declared in libsmoldyn.h with:

\begin{lstlisting}
enum ErrorCode {ECok=0, ECnotify=-1, ECwarning=-2, ECnonexist=-3, ECall=-4, ECmissing=-5, ECbounds=-6, ECsyntax=-7, ECerror=-8, ECmemory=-9, ECbug=-10, ECsame=-11}
\end{lstlisting}

Their interpretations are:

\begin{longtable}[c]{cll}
value & code & interpretation\\
\hline
0 & \ttt{ECok} & no error\\
-1 & \ttt{ECnotify} & message about correct behavior\\
-2 & \ttt{ECwarning} & unusual but not incorrect behavior\\
-3 & \ttt{ECnonexist} & a function input specifies an item that doesn't exist\\
-4 & \ttt{ECsame} & error code should be unchanged from a prior code\\
-5 & \ttt{ECall} & an argument of ``all" was found and may not be permitted\\
-6 & \ttt{ECmissing} & a necessary function input parameter is missing\\
-7 & \ttt{ECbounds} & a function input parameter is out of bounds\\
-8 & \ttt{ECsyntax} & function inputs don't make syntactical sense\\
-9 & \ttt{ECerror} & unspecified error condition\\
-10 & \ttt{ECmemory} & Smoldyn was unable to allocate the necessary memory\\
-11 & \ttt{ECbug} & error arose which should not have been possible\\

\end{longtable}

% Error checking system internal to libsmoldyn.c
\section{Error checking system internal to libsmoldyn.c}

This section describes how to write Libsmoldyn functions using error checking. While it is an essential part of all Libsmoldyn functions, these details are not important for most Libsmoldyn users.

\begin{enumerate}
\item The first line of every Libsmoldyn function should be \ttt{const char *funcname="}\emph{function\_name}\ttt{";}. This name will be returned with any error message to tell the user where the error arose.
\item Within the function, check for warnings or errors with either the \ttt{LCHECK} or \ttt{LCHECKNT} macros. In both cases, the macro format is \ttt{LCHECK(}\emph{condition}\ttt{, funcname, }\emph{error\_code}\ttt{, "}\emph{message}\ttt{");}. The macros check that the test \emph{condition} is true, and calls either \ttt{smolSetError} or \ttt{smolSetErrorNT} to deal with it if not. The \emph{message} should be a descriptive message that is under 256 characters in length. Use the regular version (not the ``no throw'' or ``NT'') version for errors that arise within the function, and the ``NT'' version for errors that arise is subroutines of the function, so that only a single error message is displayed to the output.
\item Most functions return an ``\ttt{enum ErrorCode}". If this is the case for your function, and your function might return a notification and/or a warning, then end the main body of the function with \ttt{return libwarncode;}. If it cannot return a notification or a warning, then end it with \ttt{return ECok;}. Finally, if it does not return an ``\ttt{enum ErrorCode}", then it needs to return some other error condition that will tell the user to check for errors using \ttt{smolGetError}.
\item After the main body of the function, add a goto target called \ttt{failure:}.
\item Assuming the function returns an ``\ttt{enum ErrorCode}", end the function with \ttt{return liberrorcode;}.
\end{enumerate}

The \ttt{smolSetTimeStep} function provides an excellent and simple example of how Libsmoldyn functions typically address errors. It is:

\begin{quote}
\begin{lstlisting}
enum ErrorCode smolSetTimeStep(simptr sim, double timestep) {
	const char *funcname="smolSetTimeStep";

	LCHECK(sim, funcname, ECmissing, "missing sim");
	LCHECK(timestep>0, funcname, ECbounds, "timestep is not > 0");
	simsettime(sim, timestep, 3);
	return ECok;
 failure:
	return liberrorcode; }
\end{lstlisting}
\end{quote}

The \ttt{smolGet...Index} functions are worth a comment. Each of these functions returns the index of an item, such as a species or a surface, based on the name of the item. If the name is not found or other errors arise, then these functions return the error code, cast as an integer. Also, if the name is ``all", then these functions return the error code \ttt{ECall} and set the error string ``species cannot be `all'", or equivalent. A typical use of these functions is seen in \ttt{smolSetSpeciesMobility}, which includes the following code:

\begin{quote}
\begin{lstlisting}
i=smolGetSpeciesIndex(sim, species);
if(i==(int)ECall) smolClearError();
else LCHECK(i>0, funcname, ECsame, NULL);
\end{lstlisting}
\end{quote}

In this particular case, this function permits an input of ``all", so it clears errors that arise from this return value, and leaves \ttt{i} as a negative value for later use.


% Chapter: Libsmoldyn quick function guide
\chapter{Libsmoldyn quick function guide}

The Libsmoldyn functions correspond relatively closely to the Smoldyn language statements, although not perfectly. However, all functionality should be available using either method. The following table lists the correspondences. Statements preceded by asterisks need to be either entered in statement blocks or preceded by the statement's context (e.g. with \ttt{surface} \emph{name}). Where correspondence does not apply, the table lists ``N/A". The Libsmoldyn functions are available either through the C/C++ API or through the Python API, with essentially identical input styles. The Python functions listed here use a more object-oriented approach. Here, ``S'' is short for smoldyn, arising for example as \ttt{import smoldyn as S}.

\begin{longtable}[c]{lll}
Statement & Libsmoldyn function & Python function\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{About the input}}\\
\hline
\# & N/A\\
/* ... */ & N/A\\
read\_file & \ttt{LoadSimFromFile}\\
& \ttt{ReadConfigString}\\
end\_file & N/A\\
define & N/A\\
define\_global & N/A\\
undefine & N/A\\
ifdefine & N/A\\
ifundefine & N/A\\
else & N/A\\
endif & N/A\\
display\_define & N/A\\
N/A & \ttt{SetError}\\
N/A & \ttt{GetError}\\
N/A & \ttt{ClearError}\\
N/A & \ttt{SetDebugMode}\\
N/A & \ttt{ErrorCodeToString}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Space and time}}\\
\hline
dim & \ttt{NewSim}\\
boundaries & \ttt{NewSim}\\
& \ttt{SetBoundaryType}\\
low\_wall & \ttt{NewSim}\\
& \ttt{SetBoundaryType}\\
high\_wall & \ttt{NewSim}\\
& \ttt{SetBoundaryType}\\
time\_start & \ttt{SetSimTimes}\\
& \ttt{SetTimeStart}\\
time\_stop & \ttt{SetSimTimes}\\
& \ttt{SetTimeStop}\\
time\_step & \ttt{SetSimTimes}\\
& \ttt{SetTimeStep}\\
time\_now & \ttt{SetTimeNow}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Molecules}}\\
\hline
species & \ttt{AddSpecies} & \ttt{S.Species}\\
N/A & \ttt{GetSpeciesIndex}\\
N/A & \ttt{GetSpeciesName}\\
difc & \ttt{SetSpeciesMobility} & \textit{species}\ttt{.difc}\\
difm & \ttt{SetSpeciesMobility}\\
drift & \ttt{SetSpeciesMobility}\\
mol & \ttt{AddSolutionMolecules} & \textit{species}\ttt{.addToSolution} \\
surface\_mol & \ttt{AddSurfaceMolecules}\\
compartment\_mol & \ttt{AddCompartmentMolecules}\\
molecule\_lists & \ttt{AddMolList}\\
mol\_list & \ttt{AddSpecies}\\
& \ttt{SetMolList} & \textit{species}\ttt{.mol\_list} \\
N/A & \ttt{GetMolListIndex}\\
N/A & \ttt{GetMolListName}\\
max\_mol & \ttt{SetMaxMolecules}\\
N/A & \ttt{GetMoleculeCount}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Graphics}}\\
\hline
graphics & \ttt{SetGraphicsParams}\\
graphic\_iter & \ttt{SetGraphicsParams}\\
graphic\_delay & \ttt{SetGraphicsParams}\\
frame\_thickness & \ttt{SetFrameStyle}\\
frame\_color & \ttt{SetFrameStyle}\\
grid\_thickness & \ttt{SetGridStyle}\\
grid\_color & \ttt{SetGridStyle}\\
background\_color & \ttt{SetBackgroundStyle}\\
display\_size & \ttt{SetMoleculeStyle} & \textit{species}\ttt{.setStyle}\\
& & \textit{species}\ttt{.size} \\
color & \ttt{SetMoleculeStyle} & \textit{species}\ttt{.color} \\
tiff\_iter & \ttt{SetTiffParams}\\
tiff\_name & \ttt{SetTiffParams}\\
tiff\_min & \ttt{SetTiffParams}\\
tiff\_max & \ttt{SetTiffParams}\\
light & \ttt{SetLightParams}\\
text\_color & \ttt{SetTextStyle}\\
text\_display & \ttt{AddTextDisplay}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Run-time commands}}\\
\hline
output\_root & \ttt{SetOutputPath}\\
output\_files & \ttt{AddOutputFile}\\
append\_files & \ttt{AddOutputFile}\\
output\_file\_number & \ttt{AddOutputFile}\\
cmd & \ttt{AddCommand}\\
& \ttt{AddCommandFromString}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Surfaces}}\\
\hline
start\_surface & \ttt{AddSurface}\\
new\_surface & \ttt{AddSurface}\\
{*} name & \ttt{AddSurface}\\
N/A & \ttt{GetSurfaceIndex}\\
N/A & \ttt{GetSurfaceName}\\
{*} action & \ttt{SetSurfaceAction}\\
{*} rate & \ttt{SetSurfaceRate}\\
{*} rate\_internal & \ttt{SetSurfaceRate}\\
{*} color & \ttt{SetSurfaceFaceStyle}\\
& \ttt{SetSurfaceEdgeStyle}\\
{*} thickness & \ttt{SetSurfaceEdgeStyle}\\
{*} stipple & \ttt{SetSurfaceEdgeStyle}\\
{*} polygon & \ttt{SetSurfaceFaceStyle}\\
{*} shininess & \ttt{SetSurfaceFaceStyle}\\
{*} panel & \ttt{AddPanel}\\
N/A & \ttt{GetPanelIndex}\\
N/A & \ttt{GetPanelName}\\
{*} jump & \ttt{SetPanelJump}\\
{*} neighbors & \ttt{AddPanelNeighbor}\\
{*} unbounded\_emitter & \ttt{AddSurfaceUnboundedEmitter}\\
{*} end\_surface & N/A\\
epsilon & \ttt{SetSurfaceSimParams}\\
margin & \ttt{SetSurfaceSimParams}\\
neighbor\_dist & \ttt{SetSurfaceSimParams}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Compartments}}\\
\hline
start\_compartment & \ttt{AddCompartment}\\
new\_compartment & \ttt{AddCompartment}\\
{*} name & \ttt{AddCompartment}\\
N/A & \ttt{GetCompartmentIndex}\\
N/A & \ttt{GetCompartmentName}\\
{*} surface & \ttt{AddCompartmentSurface}\\
{*} point & \ttt{AddCompartmentPoint}\\
{*} compartment & \ttt{AddCompartmentLogic}\\
{*} end\_compartment & N/A\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Reactions}}\\
\hline
reaction & \ttt{AddReaction} & \ttt{S.Reaction} \\
N/A & \ttt{GetReactionIndex}\\
N/A & \ttt{GetReactionName}\\
reaction\_cmpt & \ttt{SetReactionRegion}\\
reaction\_surface & \ttt{SetReactionRegion}\\
reaction\_rate & \ttt{AddReaction}\\
& \ttt{SetReactionRate}\\
confspread\_radius & \ttt{SetReactionRate}\\
binding\_radius & \ttt{SetReactionRate}\\
reaction\_probability & \ttt{SetReactionRate}\\
reaction\_production & \ttt{SetReactionRate}\\
reaction\_permit & not supported\\
reaction\_forbid & not supported\\
product\_placement & \ttt{SetReactionProducts}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Ports}}\\
\hline
start\_port & \ttt{AddPort}\\
new\_port & \ttt{AddPort}\\
{*} name & \ttt{AddPort}\\
N/A & \ttt{GetPortIndex}\\
N/A & \ttt{GetPortName}\\
{*} surface & \ttt{AddPort}\\
{*} face & \ttt{AddPort}\\
{*} end\_port & N/A\\
N/A & \ttt{AddPortMolecules}\\
N/A & \ttt{GetPortMolecules}\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Simulation settings}}\\
\hline
rand\_seed & \ttt{SetRandomSeed}\\
accuracy & not supported\\
molperbox & \ttt{SetPartitions}\\
boxsize & \ttt{SetPartitions}\\
gauss\_table\_size & not supported\\
epsilon & \ttt{SetSurfaceSimParams}\\
margin & \ttt{SetSurfaceSimParams}\\
neighbor\_dist & \ttt{SetSurfaceSimParams}\\
pthreads & not supported\\
\hline
\multicolumn{3}{l}{\hspace{0.3in}\textbf{Libdyn actions}}\\
\hline
N/A & \ttt{UpdateSim}\\
N/A & \ttt{RunTimeStep}\\
N/A & \ttt{RunSim}\\
N/A & \ttt{RunSimUntil}\\
N/A & \ttt{FreeSim}\\
N/A & \ttt{DisplaySim}\\
N/A & \ttt{PrepareSimFromFile}\\
\end{longtable}


% Chapter: Data structures and declarations
\chapter{Data structures and declarations}

% Enumerations
\section{Enumerations}

In C, enumerations are already defined, so they can be used as is. Here is an example of using an enumerated error code as an argument, 
\begin{lstlisting}
smolErrorCodeToString(ECwarning, mystring)
\end{lstlisting}

In Python, enumerations are most easily dealt with by defining a variable for the enumerated list and then choosing from it. Here is an example, 
\begin{lstlisting}
import smoldyn._smoldyn as S
EC=S.ErrorCode
S.errorCodeToString(EC.warning, mystring)
\end{lstlisting}

Surface actions (SrfAction)
\begin{longtable}[c]{llll}
Statement & Libsmoldyn & Python & Notes\\
\hline
reflect & SAreflect & reflect\\
transmit & SAtrans & trans\\
absorb & SAabsorb & absorb\\
jump & SAjump & jump\\
port & SAport & port\\
multiple & SAmult & mult & multiple actions\\
N/A & SAno & no & static surface-bound molecules\\
N/A & SAnone & none & none of the other options\\
N/A & SAadsorb & adsorb & internal use only\\
N/A & SArevdes & revdes & internal use only\\
N/A & SAirrevdes & irrevdes & internal use only\\
N/A & SAflip & flip & internal use only
\end{longtable}

Molecule state (MolecState)
\begin{longtable}[c]{llll}
Statement & Libsmoldyn & Python & Notes\\
\hline
soln & MSsoln & soln\\
front & MSfront & front\\
back & MSback & back\\
up & MSup & up\\
down & MSdown & down\\
bsoln & MSbsoln & bsoln & pseudo-state for surface interactions\\
all & MSall & all & for model creation by user\\
N/A & MSnone & none & internal use only
\end{longtable}

Panel face (PanelFace)
\begin{longtable}[c]{llll}
Statement & Libsmoldyn & Python & Notes\\
\hline
front & PFfront & front\\
back & PFback & back\\
N/A & PFnone & none & internal use only\\
both & PFboth & both & for model creation by user
\end{longtable}

Panel shape (PanelShape)
\begin{longtable}[c]{llll}
Statement & Libsmoldyn & Python & Notes\\
\hline
rect & PSrect & rect & rectangle\\
tri & PStri & tri & triangle\\
sph & PSsph & sph & sphere\\
cyl & PScyl & cyl & cylinder\\
hemi & PShemi & hemi & hemisphere\\
disk & PSdisk & disk & disk\\
all & PSall & all & for model creation by user\\
N/A & PSnone & none & internal use only
\end{longtable}

Libsmoldyn error code (ErrorCode)
\begin{longtable}[c]{llll}
Statement & Libsmoldyn & Python & Notes\\
\hline
N/A & ECok & ok & value 0\\
N/A & ECnotify & notify & value -1\\
N/A & ECwarning & warning & value -2\\
N/A & ECnonexist & nonexist & value -3\\
N/A & ECall & all & value -4\\
N/A & ECmissing & missing & value -5\\
N/A & ECbounds & bounds & value -6\\
N/A & ECsyntax & syntax & value -7\\
N/A & ECerror & error & value -8\\
N/A & ECmemory & memory & value -9\\
N/A & ECbug & bug & value -10\\
N/A & ECsame & same & value -11\\
N/A & ECwildcard & wildcard & value -12
\end{longtable}

% Libsmoldyn header file
\section{Libsmoldyn header file}

The Libsmoldyn header file is libsmoldyn.h. It lists all of the function declarations. This file references smoldyn.h, which lists all of the data structure declarations and enumerated type definitions.

If you compiled and installed Smoldyn using the default configuration, both files should be in your /usr/local/include/smoldyn directory. Also in this directory is the smoldyn\_config.h file. This file was used for compiling Smoldyn and Libsmoldyn but is not needed afterwards. Nevertheless, it's copied to the /usr/local/include/smoldyn directory so that programs that call Libsmoldyn can know what options Libsmoldyn was built with.


% Chapter: Libsmoldyn functions
\chapter{Libsmoldyn functions}

% General comments
\section{General comments}

None of the functions allocate memory, except within the simulation data structure. This means, for example, that all functions that return strings do not allocate these strings themselves, but instead write the string text to memory that the library user allocated and gave to the function.
All strings are fixed at \ttt{STRCHAR} characters, where this constant is defined in string2.h to 256 characters.

% Miscellaneous
\section{Miscellaneous}

\begin{description}

\item[GetVersion]
\hfill \\
C/C++: \ttt{double smolGetVersion(void)}\\
Python low-level: \ttt{float getVersion()}\\
Returns the Smoldyn version number.

\end{description}

% Errors
\section{Errors}

\begin{description}

\item[SetError]
\hfill \\
C/C++: \ttt{void smolSetError(const char *errorfunction, enum ErrorCode errorcode, const char *errorstring)}\\
C/C++: \ttt{void smolSetErrorNT(const char *errorfunction, enum ErrorCode errorcode, const char *errorstring)}\\
Python low-level: N/A\\
These functions are probably not useful for most users. Sets the Libsmoldyn error code to \ttt{errorcode}, error function to \ttt{errorfunction}, and error string to \ttt{errorstring}. The sole exception is if \ttt{errorcode} is \ttt{ECsame} then this does nothing and simply returns. Back to it's normal operation, this also either sets or clears the Libsmoldyn warning code, as appropriate. If \ttt{errorstring} is entered as \ttt{NULL}, this clears the current error string, and similarly for \ttt{errorfunction}. For the regular version without the ``NT'', if the library is being run in debug mode, then this function prints the notification, warning, or error out to stderr. It would also ideally throw exceptions if the error code is more severe than the \ttt{LibThrowThreshold} value, but this throwing doesn't work at present because throwing exceptions to the host code is incompatible with static linking.

The ``NT'' version is the ``no throw'' version, which is the same as the regular version but doesn't display messages to stderr and doesn't throw exceptions. In general, library functions should call \ttt{smolSetError} for errors caught by that function itself, and \ttt{smolSetErrorNT} for errors caught by subroutines of that function, so that each error only leads to a single call of \ttt{smolSetError}.

\item[GetError]
\hfill \\
C/C++: \ttt{enum ErrorCode smolGetError(char *errorfunction, char *errorstring, int clearerror)}\\
Python low-level: N/A\\
Returns the current LibSmoldyn error code directly, returns the function where the error occurred in \ttt{errorfunction} if it is not \ttt{NULL}, and returns the error string in \ttt{errorstring} if it is not \ttt{NULL}. Set \ttt{clearerror} to 1 to clear the error and 0 to leave any error condition unchanged.

\item[ClearError]
\hfill \\
C/C++: \ttt{void smolClearError(void)}\\
Python low-level: N/A\\
Clears any error condition.

\item[SetDebugMode]
\hfill \\
C/C++: \ttt{void smolSetDebugMode(int debugmode)}\\
Python low-level: \ttt{setDebugMode(int debugmode)}\\
Enter \ttt{debugmode} as 1 to enable debugging and 0 to disable debugging. When debug mode is turned on, all errors are displayed to stderr, as are all cleared errors. By turning on debug mode, you can often avoid checking for errors with additional code and you also typically don't need to call \ttt{smolGetError}.

\item[ErrorCodeToString]
\hfill \\
C/C++: \ttt{char* smolErrorCodeToString(enum ErrorCode erc, char *string)}\\
Python low-level: \ttt{str errorCodeToString(enum ErrorCode erc, str string)}\\
Returns a string both directly and in \ttt{string} that corresponds to the error code in \ttt{erc}. For example, if \ttt{erc} is \ttt{ECmemory}, this returns the string ``memory". To do: The string is not needed or used in the Python version.

\end{description}

% Sim structure
\section{Sim structure}

\begin{description}

\item[NewSim]
\hfill \\
Python: \textit{sim} = \ttt{Simulation(low = List[float],high = List[float])}\\
Python low-level: \ttt{simptr newSim(int dim, List[float] lowbounds, List[float] highbounds)}\\
C/C++: \ttt{simptr smolNewSim(int dim, double *lowbounds, double *highbounds)}\\
Creates and returns a new sim structure. The structure is initialized for a \ttt{dim} dimensional system that has boundaries defined by the points \ttt{lowbounds} and \ttt{highbounds}. Boundaries are transmitting (modify them with \ttt{smolSetBoundaryType}). Returns \ttt{NULL} upon failure.

\item[UpdateSim]
\hfill \\
Python: N/A\\
Python low-level: \ttt{ErrorCode updateSim()}\\
C/C++: \ttt{enum ErrorCode smolUpdateSim(simptr sim)}\\
Updates the simulation structure. This calculates all simulation parameters from physical parameters, sorts lists, and generally does everything required to make a simulation ready to run. It may be called multiple times.\\
\textbf{Python low-level to do:} doesn't work. Python wants no argument, but Libsmoldyn then complains about no argument.

\item[RunTimeStep]
\hfill \\
C/C++: \ttt{enum ErrorCode smolRunTimeStep(simptr sim)}\\
Python low-level: \ttt{ErrorCode runTimeStep()}\\
Runs one time step of the simulation. Returns an error if the simulation terminates unexpectedly during this time step or a warning if it terminates normally.\\
\textbf{Python to do:} doesn't work. Python wants no argument, but Libsmoldyn then complains about no argument.

\item[RunSim]
\hfill \\
C/C++: \ttt{enum ErrorCode smolRunSim(simptr sim)}\\
Python low-level: \ttt{ErrorCode runSim()}\\
Python: \ttt{run(stop=None, start=None, step=None)}\\
Runs the simulation until it terminates. Returns an error if the simulation terminates unexpectedly during this time step or a warning if it terminates normally.\\
\textbf{Python to do:} doesn't work. Python wants no argument, but Libsmoldyn then complains about no argument.

\item[RunSimUntil]
\hfill \\
C/C++: \ttt{enum ErrorCode smolRunSimUntil(simptr sim, double breaktime)}\\
Python low-level: \ttt{ErrorCode runSimUntil(float breaktime)}\\
Python: \ttt{runUntil(t, dt)}\\
Runs the simulation either until it terminates or until the simulation time equals or exceeds \ttt{breaktime}.\\
\textbf{Python to do:} doesn't work. Python wants no argument, but Libsmoldyn then complains about no argument.

\item[FreeSim]
\hfill \\
C/C++: \ttt{enum ErrorCode smolFreeSim(simptr sim)}\\
Python low-level: \ttt{ErrorCode freeSim()}\\
Frees the simulation data structure.

\item[DisplaySim]
\hfill \\
C/C++: \ttt{enum ErrorCode smolDisplaySim(simptr sim)}\\
Python low-level: \ttt{ErrorCode displaySim()}\\
Displays all relevant information about the simulation system to stdout.

\end{description}

% Read configuration file
\section{Read configuration file}

\begin{description}

\item[PrepareSimFromFile]
\hfill \\
C/C++: \ttt{simptr smolPrepareSimFromFile(char *filepath, char *filename, char *flags)}\\
Python low-level: \ttt{simptr prepareSimFromFile(str filename, str flags)}\\
Reads the Smoldyn configuration file that is at \ttt{filepath} and has file name \ttt{filename}, sets it up, and outputs simulation diagnostics to stdout. Returns the sim structure, or \ttt{NULL} if an error occurred. \ttt{flags} are the command line flags that are entered for normal Smoldyn use. Either or both of \ttt{filepath} and \ttt{flags} can be sent in as \ttt{NULL} if there is nothing to report. After this function runs successfully, it should be possible to call \ttt{smolRunSim} or \ttt{smolRunTimeStep}.

\item[LoadSimFromFile]
\hfill \\
C/C++: \ttt{enum ErrorCode smolLoadSimFromFile(char *filepath, char *filename, simptr *simpointer, char *flags)}\\
Python low-level: \ttt{ErrorCode loadSimFromFile(str filename, str flags)}\\
Loads part or all of a sim structure from the file that is at \ttt{filepath} and has file name \ttt{filename}. Send in \ttt{simpointer} as a pointer to sim, where sim may be an existing simulation structure that this function will append or \ttt{NULL} if it is to be created by this function. \ttt{flags} are the command line flags that are entered for normal Smoldyn use. Either or both of \ttt{filepath} and \ttt{flags} can be sent in as \ttt{NULL} if there is nothing to report. After this function runs successfully, call \ttt{smolUpdateSim} to calculate simulation parameters.

\item[ReadConfigString]
\hfill \\
C/C++: \ttt{enum ErrorCode smolReadConfigString(simptr sim, char *statement, char *parameters)}\\
Python low-level: \ttt{ErrorCode readConfigString(str statement, str parameters)}\\
Reads and processes what would normally be a single line of a configuration file. The first word of the line is the statement name, entered here as \ttt{statement}, while the rest of the line is entered as \ttt{parameters}. Separate different parameters with spaces. The same parser is used as for normal Smoldyn configuration files. This function does not make use of block style input formatting, such as for surface definitions. This means that a new surface needs to declared with ``\ttt{new\_surface} \emph{name}" and all subsequent surface definitions need to start with ``\ttt{surface} \emph{name}". Analogous rules apply to compartments and port.

\end{description}

% Simulation settings
\section{Simulation settings}

\begin{description}

\item[SetSimTimes]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetSimTimes(simptr sim, double timestart, double timestop, double timestep)}\\
Python low-level: \ttt{ErrorCode setSimTimes(float timestart, float timestop, float timestep)}\\
Sets all of the simulation time parameters to the values entered here. In addition the simulation ``time now" is set to \ttt{timestart}.

\item[SetTimeStart]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetTimeStart(simptr sim, double timestart)}\\
Python low-level: \ttt{ErrorCode setTimeStart(float timestart)}\\
Sets the simulation starting time.

\item[SetTimeStop]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetTimeStop(simptr sim, double timestop)}\\
Python low-level: \ttt{ErrorCode setTimeStop(float timestop)}\\
Sets the simulation stopping time.

\item[SetTimeNow]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetTimeNow(simptr sim, double timenow)}\\
Python low-level: \ttt{ErrorCode setTimeNow(float timenow)}\\
Sets the simulation current time.

\item[SetTimeStep]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetTimeStep(simptr sim, double timestep)}\\
Python low-level: \ttt{ErrorCode setTimeStep(float timestep)}\\
Sets the simulation time step, which must be greater than 0.

\item[SetRandomSeed]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetRandomSeed(simptr sim, double seed)}\\
Python low-level: \ttt{ErrorCode setRandomSeed(int seed)}\\
Sets the random number generator seed to \ttt{seed} if \ttt{seed} is at least 0, and sets it to the current time value if \ttt{seed} is less than 0.

\item[SetAccuracy]
\hfill \\
C/C++: not supported\\
Python: \ttt{accuracy(accuracy: float)}\\
Sets or gets the simulation accuracy.

\item[SetPartitions]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetPartitions(simptr sim, char *method, double value)}\\
Python low-level: \ttt{ErrorCode setPartitions(str method, float value)}\\
Python: \ttt{Partition(name: str, value: float)}\\
Sets the virtual partitions in the simulation volume. Enter \ttt{method} as ``molperbox" and then enter \ttt{value} with the requested number of molecules per partition volume; the default, which is used if this function is not called at all, is a target of 4 molecules per box. Or, enter \ttt{method} as ``boxsize" and enter \ttt{value} with the requested partition spacing. In this latter case, the actual partition spacing may be larger or smaller than the requested value in order to fit an integer number of partitions into each coordinate of the simulation volume.

The second Python option is its own class. I think this should be removed because partitions aren't physical objects and so don't really make sense here.

\item[MoleculePerBox]
\hfill \\
Python: \ttt{MoleculePerBox(size: float)}\\
This is only available in Python. Again, I think this should be removed because partitions aren't physical objects.

\item[Box]
\hfill \\
Python: \ttt{Box(size: float)}\\
This is only available in Python. Again, I think this should be removed because partitions aren't physical objects.


\end{description}

% Graphics
\section{Graphics}

\begin{description}

\item[SetGraphicsParams]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetGraphicsParams(simptr sim, char *method, int timesteps, double delay)}\\
Python low-level: \ttt{ErrorCode setGraphicsParams(str method, int timesteps, int delay)}\\
Python: \ttt{setGraphics(method: str, timestep: int, delay: int = 0)}\\
Sets basic simulation graphics parameters. Enter \ttt{method} as ``none" for no graphics (the default), ``opengl" for fast but minimal OpenGL graphics, ``opengl\_good" for improved OpenGL graphics, ``opengl\_better" for fairly good OpenGL graphics, or as \ttt{NULL} to not set this parameter currently. Enter \ttt{timesteps} with a positive integer to set the number of simulation time steps between graphics renderings (1 is the default) or with a negative number to not set this parameter currently. Enter \ttt{delay} as a non-negative number to set the minimum number of milliseconds that must elapse between subsequent graphics renderings in order to improve visualization (0 is the default) or as a negative number to not set this parameter currently.

\item[SetTiffParams]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetTiffParams(simptr sim, int timesteps, char *tiffname, int lowcount, int highcount)}\\
Python low-level: \ttt{ErrorCode setTiffParams(int timesteps, str tiffname, int lowcount, int highcount)}\\
Sets parameters for the automatic collection of TIFF format snapshots of the graphics window. \ttt{timesteps} is the number of simulation timesteps that should elapse between subsequent snapshots, \ttt{tiffname} is the root filename of the output TIFF files, \ttt{lowcount} is a number that is appended to the filename of the first snapshot and which is then incremented for subsequent snapshots, and \ttt{highcount} is the last numbered file that will be collected. Enter negative numbers for \ttt{timesteps}, \ttt{lowcount}, and/or \ttt{highcount} to not set these parameters, and enter \ttt{NULL} for \ttt{tiffname} to not set the file name.

\item[SetLightParams]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetLightParams(simptr sim, int lightindex, double *ambient, double *diffuse, double *specular, double *position)}\\
Python low-level: \ttt{ErrorCode smolSetLightParams(int lightindex, List[float] ambient, List[float] diffuse, List[float] specular, List[float] position)}\\
Sets the lighting parameters that are used for the rendering method ``opengl\_better". Enter \ttt{lightindex} as -1 for the global ambient light (in which case \ttt{diffuse}, \ttt{specular}, and \ttt{position} should all be \ttt{NULL}) or as 0 to 8 for one of the 8 light sources. For each light source, you can specify the 4-value color vector for the light's ambient, diffuse, and specular properties (all values should be between 0 and 1). You can also specify the 3-dimensional position for the light. To not set a property, just enter the respective vector as \ttt{NULL}.

\item[SetBackgroundStyle]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetBackgroundStyle(simptr sim, double *color)}\\
Python low-level: \ttt{ErrorCode setBackgroundStyle(string color)}\\
Sets the color of the graphics display background. \ttt{color} is a 4-value vector with red, green, blue, and alpha values (or, in Python, a color word).

\item[SetFrameStyle]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetFrameStyle(simptr sim, double thickness, double *color)}\\
Python low-level: \ttt{ErrorCode setFrameStyle(float thickness, string color)}\\
Sets the thickness and the color of the wire frame that outlines the simulation system in the graphics window. Enter \ttt{thickness} as 0 for no frame, as a positive number for the number of points in thickness, or as a negative number to not set this parameter. Enter \ttt{color} as a 4-value vector with the frame color, or as \ttt{NULL} to not set it (or, in Python, a color word).

\item[SetGridStyle]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetGridStyle(simptr sim, double thickness, double *color)}\\
Python low-level: \ttt{ErrorCode setGridStyle(float thickness, string color)}\\
Sets the thickness and the color of a grid that shows where the partitions are that separate Smoldyn's virtual boxes. Enter \ttt{thickness} as 0 for no grid, as a positive number for the number of points in thickness, or as a negative number to not set this parameter. Enter \ttt{color} as a 4-value vector with the grid color, or as \ttt{NULL} to not set it (or, in Python, a color word).

\item[SetTextStyle]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetTextStyle(simptr sim, double *color)}\\
Python low-level: \ttt{ErrorCode setTextStyle(string color)}\\
Sets the color of any text that is displayed to the graphics window. \ttt{color} is a 4-value vector with red, green, blue, and alpha values (or, in Python, a color word).

\item[AddTextDisplay]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddTextDisplay(simptr sim, char *item)}\\
Python low-level: \ttt{ErrorCode addTextDisplay(string item)}\\
Adds \ttt{item} to the list of things that Smoldyn should display as text to the graphics window. Currently supported options are ``time" and the names of species and, optionally, their states. For species and states, the graphics window shows the number of molecules.

\end{description}

% Runtime commands
\section{Runtime commands}

\begin{description}

\item[SetOutputPath]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetOutputPath(simptr sim, char *path)}\\
Python low-level: \ttt{ErrorCode setOutputPath(string path)}\\
Sets the file path for text output files to \ttt{path}.

\item[AddOutputFile]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddOutputFile(simptr sim, char *filename, int suffix, int append)}\\
Python low-level: \ttt{ErrorCode addOutputFile(string filename, int suffix, int append)}\\
Declares the file called \ttt{filename} as a file for output by one or more runtime commands. Note that spaces are not permitted in the file name. If \ttt{suffix} is non-negative, then the file name is suffixed by this integer, which can be helpful for creating output file stacks. Enter \ttt{append} as 1 if any current file should simply be appended, or to 0 if any current file should be overwritten.

\item[AddOutputData]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddOutputData(simptr sim, char *dataname)}\\
Python low-level: \ttt{ErrorCode addOutputData(string dataname)}\\
Declares the data table called \ttt{dataname}, enabling output into it by one or more runtime commands. Spaces are not permitted in the data name.

\item[OpenOutputFiles]
\hfill \\
C/C++: \ttt{enum ErrorCode smolOpenOutputFiles(simptr sim, int overwrite = 0)}\\
Opens output files for writing. Enter \ttt{overwrite} as 1 if any existing file should be overwritten. If \ttt{overwrite} is 0 and a file with this name already exists, then Smoldyn asks the user if it should be overwritten. If the user replies no, then this function ends with an error of \ttt{ECerror}.

\item[AddCommand]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddCommand(simptr sim, char type, double on, double off, double step, double multiplier, char *commandstring)}\\
Python low-level: \ttt{ErrorCode addCommand(string type, float on, float off, float step, float multiplier, string commandstring)}\\
Adds a run-time command to the simulation, including its timing instructions. This function should generally be called after \ttt{smolSetSimTimes} to make sure that command times get set correctly. The following table lists the command type options along with the other parameters that are used for each type. Parameters that are not required are simply ignored. The \ttt{commandstring} is the command name followed by any command parameters.

\begin{longtable}[c]{ll|cccc}
\ttt{type} & meaning & \ttt{on} & \ttt{off} & \ttt{step} & \ttt{multiplier}\\
\hline
\multicolumn{2}{c}{\textbf{Continuous time queue}}\\
\ttt{b} & before simulation & - & - & - & -\\
\ttt{a} & after simulation & - & - & - & -\\
\ttt{@} & at fixed time & time & - & - & -\\
\ttt{i} & fixed intervals & time on & time off & time step & -\\
\ttt{x} & exponential intervals & time on & time off & min. time step & multiplier\\
\hline
\multicolumn{2}{c}{\textbf{Integer time queue}}\\
\ttt{B} & before simulation & - & - & - & -\\
\ttt{A} & after simulation & - & - & - & -\\
\ttt{\&} & at fixed iteration & iteration & - & - & -\\
\ttt{I} & fixed iteration intervals & iter. on & iter. off & iter. step & -\\
\ttt{E} & every time step & - & - & - & -\\
\ttt{N} & every n'th time step & - & - & iter. step & -\\
\end{longtable}

\item[AddCommandFromString]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddCommandFromString(simptr sim, char *string)}\\
Python low-level: \ttt{ErrorCode addCommandFromString(str string)}\\
Defines a runtime command, including its execution timing parameters, from the string \ttt{string}. This string should be identical to ones used in configuration files, except that they do not include the ``cmd" statement.

\item[getOutputData]
\hfill \\
C/C++: \ttt{enum ErrorCode smolGetOutputData(simptr sim,char *dataname,int *nrow,int *ncol,char *array,int erase)}\\
Python low-level: vector<vector<double>> getOutputData(str dataname, bool erase)\\
Returns data that have been recorded by an observation command (e.g. molcount). Send in the name of the data in \ttt{dataname} and pointers to variables that will receive the data in: \ttt{nrow}, for the number of rows, \ttt{ncol}, for the number of columns, and \ttt{array}, for the data themselves. The data are copied over in this function from the original into the array that is returned, with the result that the data in the array can be modified as desired. \textit{The array needs to be freed by the host code.} All values in this data table are doubles, which is appropriate for some things but not so good for things like species names and molecule states. The array represents a 2D table as a single vector so to read the item at row \ttt{i} and column \ttt{j}, use \ttt{array[i*ncol+j]}. Set \ttt{erase} to 1 for the original data to be cleared after it is copied over.

\end{description}

% Molecules
\section{Molecules}

\begin{description}

\item[AddSpecies]
\hfill \\
Python: \textit{sim.}\ttt{addSpecies(name: str, state: str = "soln", color: T.Color = "", difc: float = 0.0, display\_size: int = 2, mol\_list: str = ""}\\
Python low-level: \ttt{ErrorCode addSpecies(str species, str mollist)}\\
C/C++: \ttt{enum ErrorCode smolAddSpecies(simptr sim, char *species, char *mollist)}\\
Adds a molecular species named \ttt{species} to the system. If you have already created species lists and want all states of this species to live in a specific list, then enter it in \ttt{mollist}; otherwise, enter \ttt{mollist} as \ttt{NULL} or an empty string to request default behavior.

\item[GetSpeciesIndex]
\hfill \\
C/C++: \ttt{int smolGetSpeciesIndex(simptr sim, char *species)}\\
C/C++: \ttt{int smolGetSpeciesIndexNT(simptr sim, char *species)}\\
Python low-level: \ttt{int getSpeciesIndex(str species)}\\
Returns the species index that corresponds to the species named \ttt{species}. Upon failure, this function returns an error code cast as an integer. The ``NT'' version is identical, but doesn't throw exceptions or print errors to stderr.

\item[GetSpeciesName]
\hfill \\
C/C++: \ttt{char* smolGetSpeciesName(simptr sim, int speciesindex, char *species)}\\
Python low-level: \ttt{str getSpeciesName(int speciesindex, str species)}\\
Returns the species name that corresponds to the species index in \ttt{speciesindex}. The name is returned both in \ttt{species} and directly, where the latter simplifies function use. Upon failure, this function returns \ttt{NULL}.

\item[SetSpeciesMobility]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetSpeciesMobility(simptr sim, char *species, enum MolecState state, double difc, double *drift, double *difmatrix)}\\
Python low-level: \ttt{ErrorCode setSpeciesMobility(str species, MolecState state, float difc, List[float] drift, List[float] difmatrix)}\\
Python: \textit{species}\ttt{.difc}\\
Sets any or all of the mobility coefficients for species \ttt{species} (which may be ``all") and state \ttt{state} (which may be \ttt{MSall}). \ttt{difc} is the isotropic diffusion coefficient, \ttt{drift} is the drift vector, and \ttt{difmatrix} is the square of the anisotropic diffusion matrix (see the User's manual). To not set coefficients, enter a negative number in \ttt{difc} and/or enter a \ttt{NULL} pointer in the other inputs, respectively.

The last version shown can also be used to get the diffusion coefficient for a species.


\item[AddMolList]
\hfill \\
C/C++: \ttt{int smolAddMolList(simptr sim, char *mollist)}\\
Python low-level: \ttt{int addMolList(str mollist)}\\
Adds a new molecule list, named \ttt{mollist}, to the system.

\item[GetMolListIndex]
\hfill \\
C/C++: \ttt{int smolGetMolListIndex(simptr sim, char *mollist)}\\
C/C++: \ttt{int smolGetMolListIndexNT(simptr sim, char *mollist)}\\
Python low-level: \ttt{int getMolListIndex(str mollist)}\\
Returns the list index that corresponds to the list named \ttt{mollist}. The ``NT'' version is identical but doesn't throw exceptions or print errors to the stderr output.

\item[GetMolListName]
\hfill \\
C/C++: \ttt{char* smolGetMolListName(simptr sim, int mollistindex, char *mollist)}\\
Python low-level: \ttt{str getMolListName(int mollistindex, str mollist)}\\
Returns the molecule list name that corresponds to the molecule list with index \ttt{mollistindex}. The name is returned both in \ttt{mollist} and directly. On error, this function \ttt{NULL}.

\item[SetMolList]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetMolList(simptr sim, char *species, enum MolecState state, char *mollist)}\\
Python low-level: \ttt{ErrorCode setMolList(str species, MolecState state, str mollist)}\\
Python: \textit{species}\ttt{.mol\_list}\\
Sets the molecule list for species \ttt{species} (which may be ``all") and state \ttt{state} (which may be \ttt{MSall}) to molecule list \ttt{mollist}.

The last version can either set or retrieve the molecule list.

\item[SetMaxMolecules]
\hfill \\
C/C++: \ttt{ smolSetMaxMolecules(simptr sim, int maxmolecules)}\\
Python low-level: \ttt{ setMaxMolecules(int maxmolecules)}\\
Sets the maximum number of molecules that can simultaneously exist in a system to \ttt{maxmolecules}. At present, this function needs to be called for a simulation to run, although it will become optional once dynamic molecule memory allocation has been written.

\item[AddSolutionMolecules]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddSolutionMolecules(simptr sim, char *species, int number, double *lowposition, double *highposition)}\\
Python low-level: \ttt{ErrorCode addSolutionMolecules(str species, int number, List[float] lowposition, List[float] highposition)}\\
Python: \textit{species}\ttt{.addToSolution(mol: float, highpos: List[float] = [], lowpos: List[float] = [])}\\
Adds \ttt{number} solution state molecules of species \ttt{species} to the system. They are randomly distributed within the box that has its opposite corners defined by \ttt{lowposition} and \ttt{highposition}. Any or all of these coordinates can equal each other to place the molecules along a plane or at a point. Enter \ttt{lowposition} and/or \ttt{highposition} as \ttt{NULL} to indicate that the respective corner is equal to that corner of the entire system volume.

\item[AddCompartmentMolecules]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddCompartmentMolecules(simptr sim, char *species, int number, char *compartment)}\\
Python low-level: \ttt{ErrorCode addCompartmentMolecules(str species, int number, str compartment)}\\
Adds \ttt{number} solution state molecules of species \ttt{species} to the compartment \ttt{compartment}. Molecules are randomly distributed within the compartment.

\item[AddSurfaceMolecules]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddSurfaceMolecules(simptr sim, int speciesindex, enum MolecState state, int number, int surface, enum PanelShape panelshape, int panel, double *position)}\\
Python low-level: \ttt{ErrorCode addSurfaceMolecules(int speciesindex, MolecState state, int number, int surface, PanelShape panelshape, int panel, List[float] position)}\\
Adds \ttt{number} molecules of species \ttt{species} and state \ttt{state} to surface(s) in the system. It is permissible for \ttt{surface} to be ``all", \ttt{panelshape} to be PSall, and/or \ttt{panel} to be ``all". If you want molecules at a specific position, then you need to enter a specific surface, panel shape, and panel, and then enter the position in \ttt{position}.

\item[GetMoleculeCount]
\hfill \\
C/C++: \ttt{int smolGetMoleculeCount(simptr sim, char *species, enum MolecState state)}\\
Python low-level: \ttt{int getMoleculeCount(str species, MolecState state)}\\
Returns the total number of molecules in the system that have species \ttt{species} (``all" is permitted) and state \ttt{state} (\ttt{MSall} is permitted). Any error is returned as the error code cast as an integer.

% ?? This function is redundant with SetMoleculeStyle, so I'd like to get rid of it.
\item[SetMoleculeColor]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetMoleculeStyle(simptr sim, const char *species, enum MolecState state, double *color)}\\

% ?? This function is redundant with SetMoleculeStyle, so I'd like to get rid of it.
\item[SetMoleculeSize]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetMoleculeStyle(simptr sim, const char *species, enum MolecState state, double size)}\\


\item[SetMoleculeStyle]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetMoleculeStyle(simptr sim, const char *species, enum MolecState state, double size, double *color)}\\
Python low-level: \ttt{ErrorCode setMoleculeStyle(str species, MolecState state, float size, List[float] color)}\\
Python: \textit{species}\ttt{.setStyle}\\
Python: \textit{species}\ttt{.color}\\
Python: \textit{species}\ttt{.size}\\
Sets the graphical display parameters for molecules of species \ttt{species} (``all" is permitted) and state \ttt{state} (\ttt{MSall} is permitted). Enter \ttt{size} with the drawing size (in pixels if graphics method is ``opengl" and in simulation system length units for better drawing methods) or with a negative number to not set the size. Enter \ttt{color} with the 3-value color vector or with \ttt{NULL} to not set the color (or, in Python, a color word).

\end{description}

% Surfaces
\section{Surfaces}

\begin{description}

\item[Boundaries]
\hfill \\
Python: \ttt{Boundaries(low: List[float], high: List[float], types: List[str] = field(default\_factory=lambda: ["r"]), dim: field(init=False) = 0)}\\
Python: \ttt{setBounds()}\\
This functionality is only available in Python. There is a class called \ttt{Boundaries} and a function called \ttt{setBounds}. They do basically the same thing.

\item[SetBoundaryType]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetBoundaryType(simptr sim, int dimension, int highside, char type)}\\
Python low-level: \ttt{ErrorCode setBoundaryType(int dimension, int highside, str type)}\\
Sets the molecule interaction properties for a system boundary that bounds the \ttt{dimension} axis. Enter \ttt{dimension} as -1 to indicate all dimensions. Set \ttt{highside} to 0 for the lower boundary, to 1 for the upper boundary, and to -1 for both boundaries. The boundary type is entered in \ttt{type} as `r' for reflecting, `p' for periodic, `a' for absorbing, or `t' for transmitting. Note that Smoldyn only observes these properties if no surfaces are declared; otherwise all boundaries are transmitting regardless of what's entered here.

\item[AddSurface]
\hfill \\
C/C++: \ttt{int smolAddSurface(simptr sim, char *surface)}\\
Python: \ttt{int addSurface(str surface)}\\
Adds a surface called \ttt{surface} to the system.

\item[GetSurfaceIndex]
\hfill \\
C/C++: \ttt{int smolGetSurfaceIndex(simptr sim, char *surface)}\\
C/C++: \ttt{int smolGetSurfaceIndexNT(simptr sim, char *surface)}\\
Python low-level: \ttt{int getSurfaceIndex(str surface)}\\
Returns the surface index that corresponds to the surface named \ttt{surface}. The index is non-negative. On failure, this returns an error code cast as an integer. The ``NT'' version is identical but errors aren't printed to the stderr output and don't throw exceptions.

\item[GetSurfaceName]
\hfill \\
C/C++: \ttt{char* smolGetSurfaceName(simptr sim, int surfaceindex, char *surface)}\\
Python low-level: \ttt{str getSurfaceName(int surfaceindex, str surface)}\\
Returns the surface name for surface number \ttt{surfaceindex} both directly and in the \ttt{surface} string. On failure, this returns \ttt{NULL}.

\item[SetSurfaceAction]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetSurfaceAction(simptr sim, char *surface, enum PanelFace face, char *species, enum MolecState state, enum SrfAction action, char *newspecies)}\\
Python low-level: \ttt{ErrorCode setSurfaceAction(str surface, PanelFace face, str species, MolecState state, SrfAction action)}\\
Python: \textit{surface}\ttt{.addAction(face, species: Union[Species, str], action: str, new\_spec=None)}\\
Sets the action that should happen when a molecule of species \ttt{species} (may be ``all") and state \ttt{state} (may be \ttt{MSall}) diffuses into face \ttt{face} (may be \ttt{PFboth}) of surface \ttt{surface}. The action is set to \ttt{action}. Enter \ttt{newspecies} to the name of a new species if the molecule should change species, or as either \ttt{NULL} or an empty string if it should not change species.

\item[SetSurfaceRate]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetSurfaceRate(simptr sim, char *surface, char *species, enum MolecState state, enum MolecState state1, enum MolecState state2, double rate, char *newspecies, int isinternal)}\\
Python low-level: \ttt{ErrorCode setSurfaceRate(str surface, str species, MolecState state, MolecState state1, MolecState state2, float rate, str newspecies, int isinternal)}\\
Sets the surface interaction rate(s) for surface \ttt{surface} (may be ``all") and species \ttt{species} (may be ``all") and state \ttt{state}. The transition being considered is from \ttt{state1} to \ttt{state2} (this function uses the tri-state format for describing surface interactions, shown below). The interaction rate is set to \ttt{rate}, which is interpreted as a probability value for internal use if \ttt{isinternal} is 1 and as a physical interaction coefficient if \ttt{isinternal} is 0. If the molecule ends up interacting with the surface, it changes to new species \ttt{newspecies}. Enter \ttt{newspecies} as either \ttt{NULL} or an empty string to indicate that molecules should not change species upon interactions. The molecule states are most easily understood with the following table. If the action listed in the table is in italics, then the corresponding combination of states is not a permitted input.

\begin{longtable}[c]{l|ccc|c}
interaction class&\multicolumn{3}{c}{tristate format}&action\\
&\ttt{state}&\ttt{state1}&\ttt{state2}&\\
\hline
&soln&soln&soln&\emph{reflect}\\
&"&"&bsoln&transmit\\
collision from&"&"&bound&adsorb\\
solution state&"&bsoln&soln&transmit\\
&"&"&bsoln&\emph{reflect}\\
&"&"&bound&adsorb\\
\hline
&"&bound&soln&desorb\\
action from&"&"&bsoln&desorb\\
bound state&"&"&bound&\emph{no change}\\
&"&"&bound'&flip\\
\hline
&bound&soln&soln&\emph{reflect}\\
&"&"&bsoln&transmit\\
&"&"&bound&hop\\
collision from&"&"&bound'&hop\\
bound state&"&bsoln&soln&transmit\\
&"&"&bsoln&\emph{reflect}\\
&"&"&bound&hop\\
&"&"&bound'&hop\\
\hline
&"&bound&soln&desorb\\
action from&"&"&bsoln&desorb\\
bound state&"&"&bound&\emph{no change}\\
&"&"&bound'&flip\\
\hline
impossible&"&bound'&any&\emph{nonsense}\\
\end{longtable}

\item[AddPanel]
\hfill \\
C/C++: \ttt{int smolAddPanel(simptr sim, char *surface, enum PanelShape panelshape, char *panel, char *axisstring, double *params)}\\
Python low-level: \ttt{int addPanel(str surface, PanelShape panelshape, str panel, str axisstring, List[float] params)}\\
Adds or modifies a panel of shape \ttt{panelshape} of surface \ttt{surface}. \ttt{axisstring} lists any text parameters for the panel, which in practice is only a single word that gives the orientation of a rectangle panel (e.g. ``+0" or ``-y"). \ttt{params} lists the numerical parameters for the panel location, size, and drawing characteristics. These are exactly the same parameters that are listed for the ``panel" statement in Smoldyn configuration files, with the sole exception that the first rectangle ``parameter" is actually a string that is entered in \ttt{axisstring}. \ttt{panelname} is an optional parameter for naming the panel; if it is included and is not an empty string, the panel is named \ttt{panelname}. If this panel name was already used by a panel of the same shape, then this function overwrites that panel's data with the new data. If the name was already used by a panel with a different shape, then this creates an error, and if the name was not used before, then a new panel is created. To use default panel naming, send in \ttt{panelname} as either \ttt{NULL} or as an empty string. In the latter case, \ttt{panelname} is returned with the newly assigned default name.

In Python, each panel shape is a separate class. These classes are:
\begin{itemize}
\item Rectangle: corner: List[float], dimensions: List[float], axis: str, name=""
\item Triangle: vertices: List[List[float]] = [[]], name=""
\item Sphere: center: List[float], radius: float, slices: int, stacks: int, name=""
\item Hemisphere: center: List[float], radius: float, vector: List[float], slices: int, stacks: int, name: str = ""
\item Cylinder: start: List[float], end: List[float], radius: float, slices: int, stacks: int, name=""
\item Disk: center: List[float], radius: float, vector: List[float], name=""
\end{itemize}

\item[GetPanelIndex]
\hfill \\
C/C++: \ttt{int smolGetPanelIndex(simptr sim, char *surface, enum PanelShape *panelshapeptr, char *panel)}\\
C/C++: \ttt{int smolGetPanelIndexNT(simptr sim, char *surface, enum PanelShape *panelshapeptr, char *panel)}\\
Python low-level: \ttt{int getPanelIndex(str surface, PanelShape *panelshapeptr, str panel)}\\
Returns the panel index for the panel called \ttt{panel} on surface \ttt{surface}. If \ttt{panelshapeptr} is not \ttt{NULL}, this also returns the panel shape in \ttt{panelshapeptr}. On failure, this returns the error code cast as an integer. The ``NT'' version is identical but errors aren't printed to the stderr output and don't cause exceptions to be thrown.

\item[GetPanelName]
\hfill \\
C/C++: \ttt{char* smolGetPanelName(simptr sim, char *surface, enum PanelShape panelshape, int panelindex, char *panel)}\\
Python low-level: \ttt{str getPanelName(str surface, PanelShape panelshape, int panelindex, str panel)}\\
Returns the name of the panel that is in surface \ttt{surface}, has shape \ttt{panelshape}, and has index \ttt{panelindex}, both directly and in the string \ttt{panel}. On failure, this returns \ttt{NULL}.

\item[SetPanelJump]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetPanelJump(simptr sim, const char *surface, const char *panel1, enum PanelFace face1, const char *panel2, enum PanelFace face2, int isbidirectional)}\\
Python low-level: \ttt{ErrorCode setPanelJump(str surface, str panel1, PanelFace face1, str panel2, PanelFace face2, int isbidirectional)}\\
Sets a jumping link between face \ttt{face1} of panel \ttt{panel1} and face \ttt{face2} of panel \ttt{panel2} of surface \ttt{surface}. The link goes from \ttt{panel1} to \ttt{panel2} if \ttt{bidirectional} is entered as 0 and goes in both directions if \ttt{bidirectional} is entered as 1. None of the surface, panel, or face entries is allowed to be ``all". This does not set the actions of any species to ``jump", which has to be done using the \ttt{smolSetSurfaceAction} function.

\item[AddSurfaceUnboundedEmitter]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddSurfaceUnboundedEmitter(simptr sim, const char *surface, enum PanelFace face, const char *species, double emitamount, double *emitposition)}\\
Python low-level: \ttt{ErrorCode addSurfaceUnboundedEmitter(str surface, PanelFace face, str species, float emitamount, List[float] emitposition)}\\
Adds information about a point molecular source so that face \ttt{face} of surface \ttt{surface} can have its absorption properties calculated so that the molecular concentrations will become the same as they would be if the surface weren't there at all. The point molecular source emits molecules of species \ttt{species}, with a rate of \ttt{emitamount} and is at location \ttt{emitposition}. The emission rate does not need to be in absolute units, but only has to be correct relative to other unbounded emitters. None of the inputs to this function are allowed to be ``all".

\item[SetSurfaceSimParams]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetSurfaceSimParams(simptr sim, const char *parameter, double value)}\\
Python low-level: \ttt{ErrorCode setSurfaceSimParams(str parameter, float value)}\\
Sets the surface simulation parameter named with \ttt{parameter} to value \ttt{value}. The possible parameters are ``epsilon", ``margin", and ``neighbordist". In all cases, the defaults are nearly always good, although this function allows them to be modified if desired. Epsilon is the maximum distance away from a surface that Smoldyn is allowed to place a surface-bound molecule. Margin is the distance inside from the edge of a surface panel that Smoldyn will place surface-bound molecules that hop onto this panel. Neighbor distance is the maximum distance over which surface-bound molecules are allowed to hop to transition from one panel to a neighboring panel.

\item[AddPanelNeighbor]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddPanelNeighbor(simptr sim, const char *surface1, const char *panel1, const char *surface2, const char *panel2, int reciprocal)}\\
Python low-level: \ttt{ErrorCode addPanelNeighbor(str surface1, str panel1, str surface2, str panel2, int reciprocal)}\\
Adds panel \ttt{panel2} of surface \ttt{surface2} as a neighbor of panel \ttt{panel1} or surface \ttt{surface1}, meaning that surface-bound molecules will be allowed to diffuse from \ttt{panel1} to \ttt{panel2}. These are not allowed to be the same panel. Also, ``all" values are not permitted. Otherwise, essentially any possible entries are legitimate. If surface-bound molecules should also be allowed to diffuse from \ttt{panel2} to \ttt{panel1}, enter \ttt{reciprocal} as 1; if not, enter \ttt{reciprocal} as 0.

\item[SetSurfaceStyle]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetSurfaceStyle(simptr sim, const char *surface, enum PanelFace face, enum DrawMode mode, double thickness, double *color, int stipplefactor, int stipplepattern, double shininess)}\\
Python low-level: \ttt{ErrorCode setSurfaceStyle(str surface, PanelFace face, DrawMode mode, float thickness, List[float] color, int stipplefactor, int stipplepattern, float shininess)}\\
Python: \textit{surface}\ttt{.setStyle(face, drawmode: str, color: T.Color = "", thickness: float = 1, stipplefactor: int = -1, stipplepattern: int = -1, shininess: int = -1,)}\\
Sets the graphics output style for face \ttt{face} of surface \ttt{surface}. \ttt{mode} is the drawing mode; enter it as \ttt{DMnone} to not set this parameter and otherwise enter it as \ttt{DMno} to not draw the surface, \ttt{DMvert} for vertices, \ttt{DMedge} for edges, or \ttt{DMface} for faces. The \ttt{thickness} parameter gives the point size or line width for drawing vertices or edges, or can be entered as a negative number to not set this parameter. \ttt{color} is the 4-value color vector for the surface, or can be entered as \ttt{NULL} to not set this parameter (or, in Python, a color word). \ttt{stipplefactor} is the repeat distance for the entire edge stippling pattern, or can be entered as a negative number to not set it. \ttt{stipplepattern} is the edge stippling pattern, which needs to be between 0 and 0xFFFF, or can be entered as -1 to not set this parameter. And \ttt{shininess} is the surface shininess, for use with lighting in the ``opengl\_better" graphics display option, or can be entered as -1 to not set this parameter. The parameters \ttt{thickness}, \ttt{stipplefactor}, and \ttt{stipplepattern} only apply to edge style drawing modes and ignore any input in the \ttt{face} entry. The \ttt{shininess} parameter only applies to the face style drawing modes.

\end{description}

% Compartments
\section{Compartments}

\begin{description}

\item[AddCompartment]
\hfill \\
C/C++: \ttt{int smolAddCompartment(simptr sim, char *compartment)}\\
Python low-level: \ttt{int addCompartment(str compartment)}\\
Adds a compartment called \ttt{compartment} to the system.

\item[GetCompartmentIndex]
\hfill \\
C/C++: \ttt{int smolGetCompartmentIndex(simptr sim, char *compartment)}\\
C/C++: \ttt{int smolGetCompartmentIndexNT(simptr sim, char *compartment)}\\
Python low-level: \ttt{int getCompartmentIndex(str compartment)}\\
Returns the index of the compartment named \ttt{compartment}. On failure, this returns an error code cast as an integer. The ``NT'' version is identical but errors aren't printed to the stderr output or cause exceptions to be thrown.

\item[GetCompartmentName]
\hfill \\
C/C++: \ttt{char* smolGetCompartmentName(simptr sim, int compartmentindex, char *compartment)}\\
Python low-level: \ttt{str getCompartmentName(int compartmentindex, str compartment)}\\
Returns the name of the compartment that has index \ttt{compartmentindex} both directly and in the string \ttt{compartment}. Returns \ttt{NULL} if an error arises.

\item[AddCompartmentSurface]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddCompartmentSurface(simptr sim, char *compartment, char *surface)}\\
Python low-level: \ttt{ErrorCode addCompartmentSurface(str compartment, str surface)}\\
Adds surface \ttt{surface} as one of the bounding surfaces of compartment \ttt{compartment}.

\item[AddCompartmentPoint]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddCompartmentPoint(simptr sim, char *compartment, double *point)}\\
Python low-level: \ttt{ErrorCode addCompartmentPoint(str compartment, List[float] point)}\\
Adds \ttt{point} as one of the interior-defining points of compartment \ttt{compartment}.

\item[AddCompartmentLogic]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddCompartmentLogic(simptr sim, char *compartment, enum CmptLogic logic, char *compartment2)}\\
Python low-level: \ttt{ErrorCode addCompartmentLogic(str compartment, CmptLogic logic, str compartment2)}\\
Modifies the current definition of compartment \ttt{compartment} using a logical rule specified in \ttt{logic} and the definition of \ttt{compartment2}.

\end{description}

% Reactions
\section{Reactions}

\begin{description}

\item[AddReaction]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddReaction(simptr sim, const char *reaction, const char *reactant1, enum MolecState rstate1, const char *reactant2, enum MolecState rstate2, int nproduct, const char **productspecies, enum MolecState *productstates, double rate)}\\
Python low-level: \ttt{ErrorCode addReaction(str reaction, str reactant1, MolecState rstate1, str reactant2, MolecState rstate2, int nproduct, List[str] productspecies, List[MolecState] productstates, float rate)}\\
Python: \ttt{Reaction(subs: List[Species], prds: List[Species], kf, kb=0.0)}\\
Adds reaction named \ttt{reaction} to the system. This reaction can have up to two reactants, whose species are listed in \ttt{reactant1} and \ttt{reactant2} and whose states are listed in \ttt{rstate1} and \ttt{rstate2}. If the reaction has fewer than two reactants, set either or both of \ttt{reactant1} and \ttt{reactant2} to either \ttt{NULL} or an empty string. State the number of reaction products in \ttt{nproduct}, list their species in \ttt{productspecies}, and list their states in \ttt{productstates}. To set the reaction rate, enter it in \ttt{rate}; otherwise, enter \ttt{rate} as a negative number.

\item[GetReactionIndex]
C/C++: \ttt{int smolGetReactionIndex(simptr sim, int *orderptr, char *reaction)}\\
C/C++: \ttt{int smolGetReactionIndexNT(simptr sim, int *orderptr, char *reaction)}\\
Python low-level: \ttt{int getReactionIndex(List[int] orderptr, str reaction)}\\
Returns the index and order for the reaction that is named \ttt{reaction}. If the order is known, send in \ttt{orderptr} pointing to this value. If it is not known, send in \ttt{orderptr} equal to either \ttt{NULL} or pointing to a negative number; in this case, it will be returned pointing to the reaction order, if the reaction was found. On failure, this returns the error code, cast as an integer. The ``NT'' version is identical but errors don't get displayed to the stderr output or cause exceptions to be thrown.

\item[GetReactionName]
\hfill \\
C/C++: \ttt{char* smolGetReactionName(simptr sim, int order, int reactionindex, char *reaction)}\\
Python low-level: \ttt{str getReactionName(int order, int reactionindex, str reaction)}\\
Returns the name of the reaction that has reaction order \ttt{order} and index \ttt{reactionindex} in the string \ttt{reaction}. Also returns the result directly. Returns \ttt{NULL} if an error arises.

\item[SetReactionRate]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetReactionRate(simptr sim, int order, char *reaction, double rate, int isinternal)}\\
Python low-level: \ttt{ErrorCode setReactionRate(int order, str reaction, float rate, int isinternal)}\\
Set the reaction rate to \ttt{rate}. If this value is to be interpreted as an internal reaction rate parameter, meaning the production rate for zeroth order reactions, the reaction probability for first order reactions, or the binding radius for second order reactions, then set \ttt{isinternal} to 1. Rather than calling this function at all, it's usually easier to use the \ttt{rate} parameter of the \ttt{smolAddReaction} function, although that doesn't cope with internal rate values.

\item[SetReactionRegion]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetReactionRegion(simptr sim, const char *reaction, const char *compartment, const char *surface)}\\
Python low-level: \ttt{ErrorCode setReactionRegion(str reaction, str compartment, str surface)}\\
Limits the spatial region where a reaction can take place to the compartment \ttt{compartment} and/or the surface \ttt{surface}. To not set one of these limits, enter \ttt{compartment} and/or \ttt{surface} as \ttt{NULL}. To remove a previously set limit, enter \ttt{compartment} and/or \ttt{surface} as the empty string, ``".

\item[SetReactionIntersurface]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetReactionIntersurface(simptr sim, const char *reaction, int *rulelist)}\\
Set the intersurface reaction rules for the bimolecular reaction called \ttt{reaction}. Intersurface reactions are reactions between two surface-bound molecules that are on two different surfaces. If \ttt{rulelist} is \ttt{NULL}, then this returns the reaction to the default state, which is that intersurface reactions are not allowed for this reaction. Otherwise, \ttt{rulelist} should have one entry for each product. If the entry is 1, then that product is placed on the surface with the first reactant; if it is 2, then that product is placed on the surface with the second reactant. If a reaction has no products, then create a single element in \ttt{rulelist} equal to 0 to indicate that intersurface reactions are permitted.

\item[SetReactionProducts]
\hfill \\
C/C++: \ttt{enum ErrorCode smolSetReactionProducts(simptr sim, const char *reaction, enum RevParam method, double parameter, const char *product, double *position)}\\
Python low-level: \ttt{ErrorCode setReactionProducts(str reaction, RevParam method, float parameter, str product, List[float] position)}\\
Sets the reaction product parameters for reaction \ttt{reaction}. At a minimum, the \ttt{method} reversible parameter is required. Most of these methods require a single parameter, entered in \ttt{parameter}. A few methods also require a product, in \ttt{product} and the relative position of this product in \ttt{position}.

\begin{longtable}[c]{lccc}
\ttt{method} & \ttt{parameter} & \ttt{product} & \ttt{position}\\
\hline
\ttt{RPnone} & - & - & -\\
\ttt{RPirrev} & - & - & -\\
\ttt{RPconfspread} & - & - & -\\
\ttt{RPbounce} & $\sigma_u$ & - & -\\
\ttt{RPpgem} & $\phi$ & - & -\\
\ttt{RPpgemmax} & $\phi_{max}$ & - & -\\
\ttt{RPpgemmaxw} & $\phi_{max}$ & - & -\\
\ttt{RPratio} & $\sigma_u/\sigma_b$ & - & -\\
\ttt{RPunbindrad} & $\sigma_u$ & - & -\\
\ttt{RPpgem2} & $\phi$ & - & -\\
\ttt{RPpgemmax2} & $\phi_{max}$ & - & -\\
\ttt{RPratio2} & $\sigma_u/\sigma_b$ & - & -\\
\ttt{RPoffset} & - & product number & relative position\\
\ttt{RPfixed} & - & product number & relative position\\
\end{longtable}

If \ttt{method} is \ttt{RPbounce}, then a negative number for the \ttt{parameter} indicates default bounce behavior, which is that molecules are separated by an amount that is equal to their previous overlap.

\end{description}

% Ports
\section{Ports}

\begin{description}

\item[AddPort]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddPort(simptr sim, const char *port, const char *surface, enum PanelFace face)}\\
Python low-level: \ttt{ErrorCode addPort(str port, str surface, PanelFace face)}\\
Python: \ttt{Port(name: str, surface: Union[Surface, str], panel: str)}\\
Adds a port to the simulation. The port will be named \ttt{port} and will port at the \ttt{face} face of surface \ttt{surface}.

\item[GetPortIndex]
\hfill \\
C/C++: \ttt{int smolGetPortIndex(simptr sim, const char *port)}\\
C/C++: \ttt{int smolGetPortIndexNT(simptr sim, const char *port)}\\
Python low-level: \ttt{int getPortIndex(str port)}\\
Returns the index of the port named \ttt{port}. The ``NT'' version is identical but errors don't get displayed to the stderr output or cause exceptions to be thrown.

\item[GetPortName]
\hfill \\
C/C++: \ttt{char* smolGetPortName(simptr sim, int portindex, char *port)}\\
Python low-level: \ttt{str getPortName(int portindex, str port)}\\
Returns the name of the port with index \ttt{portindex}, both directly and in \ttt{port}.

\item[AddPortMolecules]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddPortMolecules(simptr sim, const char *port, int nmolec, const char *species, double **positions)}\\
Python low-level: \ttt{ErrorCode addPortMolecules(str port, int nmolec, str species, List[float] positions)}\\
Adds \ttt{nmolec} molecules to Smoldyn's import buffer of port \ttt{port}. These molecules will all have species \ttt{species} and state \ttt{MSsoln}. Enter \ttt{positions} as \ttt{NULL} to have the molecules positioned randomly over the porting surface and as an \ttt{nmolec} length list of position vectors to have them located at those specific initial positions. These initial positions should be close to the porting surface, and on the Smoldyn system side of it.

\item[GetPortMolecules]
\hfill \\
C/C++: \ttt{int smolGetPortMolecules(simptr sim, const char *port, const char *species, enum MolecState state, int remove)}\\
Python low-level: \ttt{int getPortMolecules(str port, str species, MolecState state, int remove)}\\
Returns the number of molecules that are in Smoldyn's export buffer of port \ttt{port}. Enter \ttt{species} with the species of the molecules that should be retrieved, or ``all" for all species. Enter \ttt{state} with the states of the molecules that should be retrieved, or \ttt{MSall} for all states. Enter \ttt{remove} with 1 to remove molecules from the export buffer after they are retrieved or with 0 to leave them in the buffer. If an error arises, this returns the error code cast as an integer.

\end{description}


% Lattices
\section{Lattices}

\begin{description}

\item[AddLattice]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddLattice(simptr sim,const char *lattice,const double *min,const double *max,const double *dx,const char *btype)}\\
Python low-level: \ttt{ErrorCode AddLattice(str lattice,List[float] min,List[float] max,List[float] dx,str btype)}\\
Adds a lattice to the simulation for hybrid operation. The lattice is named \ttt{lattice} and extends from \ttt{min} to \ttt{max}, with lattice spacing \ttt{dx}. The boundary types are given with \ttt{btype}, which is a string of either `r' characters for reflective boundary or `p' characters for periodic boundary, with one character for each dimension and the dimensions listed in order (e.g. ``rrp'' is reflective on the $x$ and $y$ axes and periodic on the $z$ axis).

\item[GetLatticeIndex]
\hfill \\
C/C++: \ttt{int smolGetLatticeIndex(simptr sim,const char *lattice)}\\
C/C++: \ttt{int smolGetLatticeIndexNT(simptr sim,const char *lattice)}\\
Python low-level: \ttt{int GetLatticeIndex(str lattice)}\\
Returns the index of the lattice named \ttt{lattice}. The ``NT'' version is identical but errors don't get displayed to the stderr output or cause exceptions to be thrown.

\item[GetLatticeName]
\hfill \\
C/C++: \ttt{char *smolGetLatticeName(simptr sim,int latticeindex,char *lattice)}\\
Python low-level: \ttt{str getLatticeName(int latticeindex, str lattice)}\\
Returns the name of the lattice with index \ttt{latticeindex}, both directly and in \ttt{lattice}.

\item[AddLatticeMolecules]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddLatticeMolecules(simptr sim,const char *lattice, const char *species,int number,double *lowposition,double *highposition)}\\
Python low-level: \ttt{ErrorCode AddLatticeMolecules(str lattice, str species, int number, List[float] lowposition, List[float] highposition)}\\
Adds \ttt{number} molecules of species \ttt{species} to the lattice named \ttt{lattice}, randomly positioned over the volume extending from \ttt{lowposition} to \ttt{highposition}. These molecules will all have state \ttt{MSsoln}.

\item[AddLatticePort]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddLatticePort(simptr sim, const char *lattice, const char *port)}\\
Python low-level: \ttt{ErrorCode AddLatticePort(str lattice, str port)}\\
Connects port \ttt{port} with lattice \ttt{lattice}, so that molecules can transition across this port between the particle-based simulation region and the lattice-based simulation region.

\item[AddLatticeSpecies]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddLatticeSpecies(simptr sim,const char *lattice, const char *species)}\\
Python low-level: \ttt{ErrorCode AddLatticeSpecies(str lattice, str species)}\\
Not all particle-based Smoldyn species are necessarily listed in a lattice portion of space, so use this function to add species to the lattice region of space. Clearly, the lattice is \ttt{lattice} and the species being added is \ttt{species}.

\item[AddLatticeReaction]
\hfill \\
C/C++: \ttt{enum ErrorCode smolAddLatticeReaction(simptr sim,const char *lattice, const char *reaction, const int move)}\\
Python low-level: \ttt{ErrorCode AddLatticeReaction(str lattice, str reaction, int move)}\\
Not all particle-based Smoldyn reactions are necessarily listed in a lattice portion of space, so use this function to add reactions to the lattice region of space. Clearly, the lattice is \ttt{lattice} and the reaction being added is \ttt{reaction}.

\end{description}

\end{document}
